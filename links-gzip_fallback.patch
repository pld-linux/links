--- links-1.03/configure.in.orig	2013-06-21 20:16:45.722573508 +0200
+++ links-1.03/configure.in	2013-06-21 20:48:49.859159434 +0200
@@ -365,6 +365,9 @@
 fi
 AC_MSG_RESULT($cf_result)
 
+AC_CHECK_HEADERS([zlib.h])
+AC_CHECK_LIB([z], [gzdopen])
+
 #ifdef HAVE_SSL
 ssld=yes
 AC_ARG_WITH(ssl, [  --with-ssl(=directory)  enable SSL support], [if test "$withval" = no; then disable_ssl=yes; else ssld="$withval"; fi])
--- links-1.03/file.c.orig	2011-11-16 03:26:53.000000000 +0100
+++ links-1.03/file.c	2013-06-21 21:00:28.615796496 +0200
@@ -228,9 +228,14 @@
 		mem_free(name);
 		setcstate(c, S_FILE_TYPE); abort_connection(c); return;
 	}
+opening:
 	if ((h = open(name, O_RDONLY | O_NOCTTY)) == -1) {
 		int er = errno;
 		if ((d = opendir(name))) goto dir;
+		if (strncmp(name + strlen(name) - 3, ".gz", 3) != 0) {
+			add_to_strn(&name, ".gz");
+			goto opening;
+		} 
 		mem_free(name);
 		setcstate(c, get_error_from_errno(er));
 		abort_connection(c);
@@ -363,12 +368,43 @@
 		add_to_str(&file, &fl, "</pre></body></html>\n");
 		head = stracpy("\r\nContent-Type: text/html\r\n");
 	} else {
-		mem_free(name);
 		if (stt.st_size > MAXINT) {
+			mem_free(name);
 			close(h);
 			setcstate(c, S_LARGE_FILE); abort_connection(c);
 			return;
 		}
+#ifdef HAVE_ZLIB_H
+		if (strncmp(name + strlen(name) - 3, ".gz", 3) == 0) {
+		/* decompression */
+			gzFile gh = gzdopen(h, "r");
+			fl = 0;
+			mem_free(name);
+			if (!gh) {
+				close(h);
+				setcstate(c, S_OUT_OF_MEM); abort_connection(c); return;
+			}
+			if (!(file = mem_alloc(stt.st_size + !stt.st_size))) {
+				gzclose(gh);
+				setcstate(c, S_OUT_OF_MEM); abort_connection(c); return;
+			}
+			while ((r = gzread(gh, file+fl, stt.st_size)) > 0) {
+				fl += r;
+				file = mem_realloc(file, fl + stt.st_size);
+				if (!file) {
+					gzclose(gh);
+					setcstate(c, S_OUT_OF_MEM);
+					abort_connection(c);
+					return;
+				}
+			}	
+			gzclose(gh);
+			head = stracpy("");
+		}
+		else 
+#endif
+		{
+  		mem_free(name);
 		/* + !stt.st_size is there because of bug in Linux. Read returns
 		   -EACCES when reading 0 bytes to invalid address */
 		file = mem_alloc(stt.st_size + !stt.st_size);
@@ -380,6 +416,7 @@
 		close(h);
 		fl = stt.st_size;
 		head = stracpy("");
+		}
 	}
 	if (get_cache_entry(c->url, &e)) {
 		mem_free(file);
--- links-0.97/links.h	Wed Jul  3 10:36:17 2002
+++ links-0.97/links.h.new	Wed Jul  3 10:44:18 2002
@@ -97,6 +97,10 @@
 #include <openssl/ssl.h>
 #endif
 
+#ifdef HAVE_ZLIB_H
+#include <zlib.h>
+#endif
+
 #include "os_depx.h"
 
 #include "setup.h"
